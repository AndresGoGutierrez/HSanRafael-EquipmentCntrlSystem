"""
Unit tests for the security module.

This suite validates two critical areas of the security system:
1. Password hashing and verification using bcrypt.
2. JWT creation and decoding, ensuring token integrity and expiration handling.
"""

import unittest
from datetime import timedelta
from app.core.security import (
    verify_password,
    get_password_hash,
    create_access_token,
    decode_access_token
)


class TestPasswordHashing(unittest.TestCase):
    """
    Unit tests for password hashing and verification functions.

    These tests ensure the correctness and reliability of bcrypt-based password
    hashing, including salt randomness, verification logic, and the non-reversible
    nature of the generated hashes.
    """

    def setUp(self):
        """
        Define common setup for all password hashing tests.

        Initializes a secure test password used in all test cases.
        """
        self.password = "SecurePassword123!"

    def test_hash_password_generates_valid_bcrypt(self):
        """
        Test that password hashing produces a valid bcrypt hash.

        Verifies:
        - The resulting hash is not None.
        - The hash differs from the plain password.
        - The hash string begins with '$2b$', identifying bcrypt format.
        """
        hashed = get_password_hash(self.password)

        self.assertIsNotNone(hashed)
        self.assertNotEqual(self.password, hashed)
        self.assertTrue(hashed.startswith("$2b$"))  # bcrypt indicator

    def test_verify_correct_password(self):
        """
        Test that `verify_password` returns True for valid credentials.

        Ensures bcrypt comparison correctly validates the right password.
        """
        hashed = get_password_hash(self.password)

        self.assertTrue(verify_password(self.password, hashed))

    def test_verify_incorrect_password(self):
        """
        Test that `verify_password` rejects an incorrect password.

        Ensures authentication fails if a wrong password is used.
        """
        hashed = get_password_hash(self.password)

        self.assertFalse(verify_password("WrongPassword456!", hashed))

    def test_hashing_same_password_generates_different_salts(self):
        """
        Test that hashing the same password multiple times produces different hashes.

        Since bcrypt adds a random salt per operation, hashes must be unique
        while still verifying successfully against the same password.
        """        
        hash1 = get_password_hash(self.password)
        hash2 = get_password_hash(self.password)

        self.assertNotEqual(hash1, hash2)
        self.assertTrue(verify_password(self.password, hash1))
        self.assertTrue(verify_password(self.password, hash2))


class TestJWTTokens(unittest.TestCase):
    """
    Unit tests for JWT token creation and decoding.

    These tests verify that JWTs generated by the application are valid,
    decodable, include expiration when applicable, and reject tampered or
    invalid tokens gracefully.
    """


    def test_create_access_token_returns_valid_string(self):
        """
        Test that `create_access_token` returns a valid non-empty string.

        The token should be a properly formatted JWT string suitable for
        client authentication.
        """
        token = create_access_token({"sub": "testuser", "user_id": 1})

        self.assertIsNotNone(token)
        self.assertIsInstance(token, str)
        self.assertGreater(len(token), 10)  # basic check to avoid trivial strings

    def test_token_with_expiration_is_decodable(self):
        """
        Test that tokens created with a custom expiration are decodable.

        Verifies:
        - Token includes an `exp` (expiration) claim.
        - The subject (`sub`) is correctly encoded and retrievable.
        """
        expires_delta = timedelta(minutes=15)
        token = create_access_token({"sub": "testuser"}, expires_delta)

        payload = decode_access_token(token)

        self.assertIsNotNone(payload)
        self.assertEqual(payload["sub"], "testuser")
        self.assertIn("exp", payload)

    def test_decode_valid_token_returns_payload(self):
        """
        Test that decoding a valid token returns its correct payload.

        Ensures JWT integrity and payload structure are preserved after decoding.
        """
        token = create_access_token({"sub": "testuser", "user_id": 1, "role": "ti"})

        payload = decode_access_token(token)

        self.assertIsNotNone(payload)
        self.assertEqual(payload["sub"], "testuser")
        self.assertEqual(payload["user_id"], 1)
        self.assertEqual(payload["role"], "ti")

    def test_decode_invalid_token_returns_none(self):
        """
        Test that invalid or malformed tokens return None upon decoding.

        Prevents crashes or exceptions when invalid tokens are encountered.
        """
        payload = decode_access_token("invalid.token.here")

        self.assertIsNone(payload)

    def test_decode_tampered_token_returns_none(self):
        """
        Test that tampering with a valid token causes decoding failure.

        Verifies that even small alterations to the token signature result in
        a rejection, maintaining token security and integrity.
        """
        token = create_access_token({"sub": "testuser"})

        tampered_token = token[:-5] + "XXXXX"  # alter the signature

        payload = decode_access_token(tampered_token)

        self.assertIsNone(payload)


if __name__ == "__main__":
    unittest.main()
